#week12

---

## Algorithm [832. Flipping an Image](https://leetcode.com/problems/flipping-an-image/)
### 1. 问题描述
水平翻转图像

给定一个二进制矩阵 A，A 表示图像，水平翻转图像，然后反转它，并返回得到的图像。

水平翻转图像，意思是图像的每一行都是反向的。如 水平翻转 [1,1,0] 的结果是 [0,1,1]

反转图像意思是把其中的 0 都替换成 1， 1 都替换成 0. 例如，反转 [0,1,1] 的结果是 [1,0,0]

示例1：
输入： [[1,1,0],[1,0,1],[0,0,0]]
输出： [[1,0,0],[0,1,0],[1,1,1]]
解释：翻转每一行之后：[[0,1,1],[1,0,1],[0,0,0]]
；然后反转图像：[[1,0,0],[0,1,0],[1,1,1]]

示例2：
输入： [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出： [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释：翻转每一行之后：[[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
然后反转图像：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

### 2. 解题思路
对于二维数组A，对于每一个行 A[i] 兑换 A[i][j] 和 A[i][len(A[i]) - j - 1] 的值，并取反

### 3. 代码
```go
func flipAndInvertImage(A [][]int) [][]int {
	for i := 0; i < len(A); i++ {
		leni := len(A[i]);
		for j := 0; j < (leni + 1)/2; j++ {
			A[i][j],A[i][leni - j - 1] = A[i][leni - j - 1]^1,A[i][j]^1
		}
	}
	return A
}
```
### 4. 复杂度分析
* 时间复杂度：O(N*M) 其中 N 是行数，M 是列数, 确切的说应该是 N*(M/2) 因为每一行只需要遍历一半
* 空间复杂度：O(1)

---

## Review [1. Spring WebFlux](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux)

---

## Tip

### 

---
    
## Share
### 

