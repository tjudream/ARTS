#week14

---

## Algorithm [961. N-Repeated Element in Size 2N Array](https://leetcode.com/problems/n-repeated-element-in-size-2n-array/)
### 1. 问题描述
在长度为 2N 的数组中，找出重复 N 次的元素

给定一个数组 A 长度为 2N，其中包含 N + 1 个非重复元素，其中有且仅有一个元素重复了 N 次。

找到这个重复了 N 次的元素。

示例1：
* 输入：[1,2,3,3]
* 输出：3

示例2：
* 输入：[2,1,2,5,3,2]
* 输出：2

示例3：
* 输入：[5,1,5,2,5,3,5,4]
* 输出：5
### 2. 解题思路
####算法1：计数法
1. 从头开始遍历数组
2. 用一个 hashmap 记录下所有出现过的元素
3. 遍历的时候在 hashmap 中查找该元素是否在 hashmap中
    * 如果在 hashmap 中，则该元素就是要找的那个元素
####算法2：比较法
* 将原数组分成长度为 4 的子数组，则至少在其中一个子数组中包含 2 个要找的元素。

证明：
1. 将原数组分成长度为 2 的子数组，共可以分成 N 个 2 元组
2. 有以下2种情况：
* (1) 每个 2 元组中都包含都包含且只包含一个要找的元素，那么组成 4 元组后，则每个 4 元组中都有 2 个要找的元素
* (2) 有一个 2 元组中不包含要找的元素，那么至少有另一个 2 元组中全是要找的元素（因为要找的元素有 N 个），那么组成 4 元组后，至少有一个 4 元组中包含了 2 个要找的元素

因此可以：
1. 遍历数组
2. 比较当前元素与其前边相邻的 3 个元素中是否有相同的，如果有则返回
### 3. 代码
#### 算法1： 计数法
```go
func repeatedNTimes(A []int) int {
	dict := make([]int, 10000)
	for i := 0; i < len(A); i++ {
		if dict[A[i]] == 0 {
			dict[A[i]] = 1
		} else {
			return A[i]
		}
	}
	return -1
}
```
#### 算法2：比较法
```go
func repeatedNTimes2(A []int) int {
	a := -1
	b := -1
	c := -1
	for i := 0; i < len(A); i++ {
		if A[i] == a {
			return a
		}
		if A[i] == b {
			return b
		}
		if A[i] == c {
			return c
		}
		a = b
		b = c
		c = A[i]
	}
	return -1
}
```
### 4. 复杂度分析
#### 算法1：计数法
* 时间复杂度： O(N)
* 空间复杂度： O(N)
#### 算法2：比较法
* 时间复杂度：O(N)
* 空间复杂度：O(1)

---

## Review []()

---

## Tip

### 

---
    
## Share
### 

